---
title: "Chap3.4"
output: html_document
date: "2025-10-06"
---

**Codes for iE method function (accelerated)**

```{r}

# negative likelihood function for gamma dist
target_gamma=function(theta,x){
  alpha <- theta[1]
  beta <- theta[2]
  n <- length(x); sumd <- sum(x);sumlogd <- sum(log(x))
  gmll <-  n*alpha*log(beta) +n*lgamma(alpha)+sumd/beta-(alpha-1)*sumlogd
  return(gmll)
}

 iE_sgamma <- function(mle_alpha,mle_beta,x,max_ite=50,B=50){   
  sample_size <- length(x)
  records <- matrix(NA,nrow=max_ite+1,ncol = 2)
  records[1,1] <- mle_alpha
  records[1,2] <- mle_beta
  for(i in 1:max_ite){
  j <- 1
  Boot <-  matrix(NA,nrow=B,ncol = 2)
  while(j <=B){
    sample_gamma<- rgamma(n=n,shape= records[i,1],scale=records[i,2])

    MOM_alpha <- mean(sample_gamma)^2/var(sample_gamma)
    MOM_beta <- var(sample_gamma)/ mean(sample_gamma)
    model <- optim(par =c(MOM_alpha,MOM_beta),target_gamma, x=sample_gamma,hessian = TRUE,method = "L-BFGS-B",lower = 0.00001)
    if( model$convergence ==0){
    Boot[j,] <- model$par
    j <- j +1
    }        
  }          
    records[(i+1),] <- records[i,] + i^{-0.7}* (records[1,]-colMeans(Boot))

}
  
    
  return(records[max_ite,])
}


#contractive_iteration_cexp(mle_mu,exp_sampled,c=1)

#iE_sgamma(mle_gamma_update[1],mle_gamma_update[2],sample_gamma,max_ite=50,B=50)

```

**Codes for analytical iE method function (explicit bias)**

```{r}

pdf <- quote(1/ (beta^alpha*gamma(alpha)) * x^(alpha - 1) *
exp(-x/beta))
lpdf <- quote(-alpha * log(beta) - lgamma(alpha) +
(alpha-1) * log(x) - x / beta)

 iE_sgamma_analytical <- function(mle,x,tolerance=0.000001,max_ite=50){
  sample_size <- length(x)
  record <- matrix(0,nrow =max_ite+1,ncol = 2)
  record[1,] <- mle
  diff <- 1
  i<-1
  while(diff >tolerance && i <=max_ite){
    new_candidate <- record[1,]-coxsnell.bc(density = pdf, logdensity = lpdf, n = sample_size,
        parms = c("alpha", "beta"), mle = 
  record[i,],
        lower = 0)$bias #update equation
    record[i+1,] <- new_candidate
    diff <- abs(record[i+1,][1]-record[i,][1])
    i <-i+1
  }

  if(diff >tolerance ){ #divergence
    return(record[1,])

  }else{
    return(record[i,])
   }
}


#contractive_iteration_cexp(mle_mu,exp_sampled,c=1)



```

**Codes for Firth's method function**

```{r}

Firth_method_gamma2 <- function(mle,x,tolerance=0.000001,max_ite=50){   
  
  record <- matrix(0,nrow =max_ite+1,ncol = 2)
  record[1,] <- mle
  #bias <- vector(mode='numeric',length=0)
  diff <- 1
  #i<-1
  for( i in 1:max_ite){
    
  temp <- record[i,]+solve(obs_informa(
  record[i,],sample_gamma))%*% matrix(score_alpha(
  record[i,],sample_gamma))
    
    new_candidate <- temp-coxsnell.bc(density = pdf, logdensity = lpdf, n = sample_size,
        parms = c("alpha", "beta"), mle = 
  record[i,],
        lower = 0)$bias  #update equation
    record[(i+1),] <-new_candidate #cbind(record,new_candidate)
    #diff <- abs(record[(i+1),][1]-record[i,][1])
    #i <-i+1
  }
  return(record[max_ite,])
}

```

**Codes for One-step method function**

In this case, the cox method becomes a naive bias reduction equation since there is an explicit form of the bias in exponential case.

```{r}
#Contractive iteration
pdf <- quote(1/ (beta^alpha*gamma(alpha)) * x^(alpha - 1) *
exp(-x/beta))
lpdf <- quote(-alpha * log(beta) - lgamma(alpha) +
(alpha-1) * log(x) - x / beta)  

Cox_sgamma <- function(mle,x){
  
  n <- length(x)
  
  return(mle-coxsnell.bc(density = pdf, logdensity = lpdf, n = n,
          parms = c("alpha", "beta"), mle =
          mle,
                lower = 0)$bias)

  
}

  
```


**Codes for Bootstrap method function**

The bootstrap method is based on the equation:$\tilde{\theta}- \hat{\theta} \approx \hat{\theta}-\bar{\theta}_{boot}$ and then the bias-corrected MLE $\tilde{\theta}$could be achieved by : $\tilde{\theta}=2 \hat{\theta}-\bar{\theta}_{boot}$, where $\bar{\theta}_{boot}$ is the mean of all bootstrapped MLE under the $\hat{\theta}$.

```{r}
#Bootstrap method

Boot_sgamma <- function(mle,x,bootstrap_t =50){
  
  n <- length(x)
  Boot <-  matrix(0,nrow =bootstrap_t,ncol = 2)
  j <- 1
  while( j < (bootstrap_t+1)){ # Bootstrap procedure
      
    sample_gamma<- rgamma(n=n,shape= mle[1],scale=mle[2])

    MOM_alpha <- mean(sample_gamma)^2/var(sample_gamma)
    MOM_beta <- var(sample_gamma)/ mean(sample_gamma)
    model <- optim(par =c(1,1),target_gamma, x=sample_gamma,hessian = TRUE,method = "L-BFGS-B",lower = 0.00001)
    if ( model$convergence ==0){
    Boot[j,] <- model$par
    j<- j+1
    }
  }
  theta_bootstrap <- 2*mle-colMeans(Boot)
  return(theta_bootstrap)   #Bootstrap updating equation
}

  
```


**Codes for Jackknife method function**



```{r}
#Bootstrap method

Jackknife_sgamma <- function(mle,x){
  n <- length(x)
  Jack_mle_leave_one_out <-matrix(0,nrow =n,ncol = 2)
  for( i in 1:n){ # Bootstrap procedure
      
      Jackknife_sample <- x[-i]
      

      MOM_alpha <- mean(Jackknife_sample)^2/var(Jackknife_sample)
      MOM_beta <- var(Jackknife_sample)/ mean(Jackknife_sample)
      model <- optim(par =c(MOM_alpha,MOM_beta),target_gamma, x=sample_gamma,hessian = TRUE,method = "L-BFGS-B",lower = 0.00001)

      Jack_mle_leave_one_out[i,] <- model$par

  }
  
  theta_tilde <- n*mle-(n-1)*colMeans(Jack_mle_leave_one_out)
  return(theta_tilde)   #Jackknife equation
}

  
```





Now, we run those methods by 10000 times and compare the mean and the mean squared error of bias-corrected mle of each method. 

```{r,cache=TRUE}

set.seed(1234)

library(mle.tools)
true_alpha_gamma<-5  #true value
true_beta_gamma <- 10
sample_size <-20
tolerance <- 0.00001

n_trials <- 1000
bc_gamma_anaiE <- matrix(0,nrow=n_trials,ncol = 2)
bc_gamma_Jacknife<- matrix(0,nrow=n_trials,ncol = 2)
bc_gamma_Boot<- matrix(0,nrow=n_trials,ncol = 2)
bc_gamma_Cox<- matrix(0,nrow=n_trials,ncol = 2)
bc_gamma_iE<- matrix(0,nrow=n_trials,ncol = 2)
bc_gamma_firth <- matrix(0,nrow=n_trials,ncol = 2)
mle_gamma <- matrix(0,nrow=n_trials,ncol = 2)
# negative likelihood function for gamma dist
target_gamma=function(theta,x){
  alpha <- theta[1]
  beta <- theta[2]
  n <- length(x); sumd <- sum(x);sumlogd <- sum(log(x))
  gmll <-  n*alpha*log(beta) +n*lgamma(alpha)+sumd/beta-(alpha-1)*sumlogd
  return(gmll)
  }

#Formula deduced from Cox-Snell
pdf <- quote(1/ (beta^alpha*gamma(alpha)) * x^(alpha - 1) *
exp(-x/beta))
lpdf <- quote(-alpha * log(beta) - lgamma(alpha) +
(alpha) * log(x) - x / beta)

#score function of gamma
score_alpha <- function(theta,sample_gamma_alpha){
  n<-length(sample_gamma_alpha)
  sumlog <- sum(log(sample_gamma_alpha))
  sumd <- sum(sample_gamma_alpha)
  alpha <-theta[1]
  beta <-theta[2]
  score_alpha <- -n*digamma(alpha)-n*log(beta)+sumlog
  score_beta <- -n*alpha/beta+ sumd/beta^2
  return(c(score_alpha,score_beta))
}

#observed information matrix
obs_informa <- function(theta,sample_gamma_alpha){
  n<-length(sample_gamma_alpha)
  alpha <- theta[1]
  beta <-theta[2]
  I_11 <- -n*trigamma(alpha)
  I_12 <- -n/beta
  I_21 <- -n/beta
  I_22 <- n*alpha/beta^2 -2*sum(sample_gamma_alpha)/beta^3
  obs_I <- -matrix(c(I_11,I_12,I_21,I_22),ncol = 2)
  return( obs_I)
  
}
t <-1
while(t <= n_trials){

  sample_gamma <-rgamma(sample_size,shape= true_alpha_gamma,scale=true_beta_gamma)
  alpha_m <- mean(sample_gamma)^2/var(sample_gamma)
  beta_m <- var(sample_gamma)/ mean(sample_gamma)
      
  check <- optim(par =c(alpha_m,beta_m),target_gamma, x=sample_gamma,hessian = TRUE)
  #mle_gamma_update<-check$par
  mle_gamma_update<-check$par
  mle_gamma[t,] <- mle_gamma_update
  if ( check$convergence ==0){
# 
    try(

      {
        bc_gamma_anaiE[t,] <- iE_sgamma_analytical(mle_gamma_update,sample_gamma,max_ite=20)
        bc_gamma_iE[t,] <- iE_sgamma(mle_gamma_update[1],mle_gamma_update[2],sample_gamma,max_ite=20,B=50)
        bc_gamma_firth[t,] <-  Firth_method_gamma2(mle_gamma_update,sample_gamma,tolerance = tolerance)
        bc_gamma_Cox[t,] <- Cox_sgamma(mle_gamma_update,x=sample_gamma)
        bc_gamma_Boot[t,] <- Boot_sgamma(mle_gamma_update,x=sample_gamma,bootstrap_t = 50)
        bc_gamma_Jacknife[t,] <- Jackknife_sgamma(mle_gamma_update,x=sample_gamma)
        t <- t+1
      },silent = TRUE
    )
}
}


result_gamma_alpha <- matrix(0,nrow = 2,ncol =7)
colnames(result_gamma_alpha) <- c('MLE_alpha','iE alpha','Firth alpha','Cox alpha','Boot alpha','Jack alpha','Analytical iE alpha')
rownames(result_gamma_alpha) <- c('mean','MSE')

result_gamma_alpha[1,] <- c(mean(mle_gamma[,1]),mean(bc_gamma_iE[,1]),mean(bc_gamma_firth[,1]),mean(bc_gamma_Cox[,1]),mean(bc_gamma_Boot[,1]),mean(bc_gamma_Jacknife[,1]),mean(bc_gamma_anaiE[,1]))
result_gamma_alpha[2,] <- c(mean((mle_gamma[,1]-true_alpha_gamma)^2),mean((bc_gamma_iE[,1]-true_alpha_gamma)^2),mean((bc_gamma_firth[,1]-true_alpha_gamma)^2),mean((bc_gamma_Cox[,1]-true_alpha_gamma)^2),mean((bc_gamma_Boot[,1]-true_alpha_gamma)^2),mean((bc_gamma_Jacknife[,1]-true_alpha_gamma)^2),mean((bc_gamma_anaiE[,1]-true_alpha_gamma)^2))

knitr::kable(
  result_gamma_alpha, booktabs = TRUE,
  caption = 'Comparison with Firth method in two parameters case.Gamma distribution with alpha=5,beta=10'
)



result_gamma_beta <- matrix(0,nrow = 2,ncol = 7)
colnames(result_gamma_beta) <- c('MLE_alpha','iE alpha','Firth alpha','Cox alpha','Boot alpha','Jack alpha','Analytical iE alpha')
rownames(result_gamma_beta) <- c('mean','MSE')

result_gamma_beta[1,] <- c(mean(mle_gamma[,2]),mean(bc_gamma_iE[,2]),mean(bc_gamma_firth[,2]),mean(bc_gamma_Cox[,2]),mean(bc_gamma_Boot[,2]),mean(bc_gamma_Jacknife[,2]),mean(bc_gamma_anaiE[,2]))
result_gamma_beta[2,] <- c(mean((mle_gamma[,2]-true_beta_gamma)^2),mean((bc_gamma_iE[,2]-true_beta_gamma)^2),mean((bc_gamma_firth[,2]-true_beta_gamma)^2),mean((bc_gamma_Cox[,2]-true_beta_gamma)^2),mean((bc_gamma_Boot[,2]-true_beta_gamma)^2),mean((bc_gamma_Jacknife[,2]-true_beta_gamma)^2),mean((bc_gamma_anaiE[,2]-true_beta_gamma)^2))

knitr::kable(
  result_gamma_beta, booktabs = TRUE,
  caption = 'Comparison with Firth method in two parameters case.Gamma distribution with alpha=5,beta=10'
)
```
