---
title: "Chap3.4"
output: html_document
date: "2025-10-06"
---

**Codes for iE method function (accelerated)**

```{r}


 iE_weibull <- function(mle_alpha,mle_beta,x,max_ite=50,B=50){   
  sample_size <- length(x)
  records <- matrix(NA,nrow=max_ite+1,ncol = 2)
  records[1,1] <- mle_alpha
  records[1,2] <- mle_beta
  for(i in 1:max_ite){
  j <- 1
  Boot <-  matrix(NA,nrow=B,ncol = 2)
  while(j <=B){
    sample_weibull <-rweibull(sample_size,shape= records[i,1],scale=records[i,2])
    MOM_k_weibull <- pi/(sqrt(6)*sd(sample_weibull)) #shape
    MOM_lambda_weibull <- exp(mean(sample_weibull)-0.5772/MOM_k_weibull)  #scale
    model <-  optim(par = c(MOM_k_weibull,MOM_lambda_weibull),target_weibull, x=sample_weibull, hessian=TRUE)
    if( model$convergence ==0){
    Boot[j,] <- model$par
    j <- j +1
    }        
  }          
    records[(i+1),] <- records[i,] + i^{-0.7}* (records[1,]-colMeans(Boot))

}
  
    
  return(records[max_ite,])
}


#contractive_iteration_cexp(mle_mu,exp_sampled,c=1)

#iE_sgamma(mle_gamma_update[1],mle_gamma_update[2],sample_gamma,max_ite=50,B=50)

```

**Codes for analytical iE method function (explicit bias)**

```{r}

#Formula deduced from Cox-Snell
pdf <- quote(k/lambda^k*x^(k-1)*exp(-(x/lambda)^k))
lpdf <- quote(log(k)-k*log(lambda)+k*log(x)-(x/lambda)^k)

 iE_weibull_analytical <- function(mle,x,tolerance=0.000001,max_ite=50){
  sample_size <- length(x)
  record <- matrix(0,nrow =max_ite+1,ncol = 2)
  record[1,] <- mle
  diff <- 1
  i<-1
  while(diff >tolerance && i <=max_ite){
    new_candidate <- record[1,]-coxsnell.bc(density = pdf, logdensity = lpdf, n = sample_size,
        parms = c("k", "lambda"), mle = 
  record[i,],
        lower = 0)$bias #update equation
    record[i+1,] <- new_candidate
    diff <- abs(record[i+1,][1]-record[i,][1])
    i <-i+1
  }

  if(diff >tolerance ){ #divergence
    return(record[1,])

  }else{
    return(record[i,])
   }
}


#contractive_iteration_cexp(mle_mu,exp_sampled,c=1)



```

**Codes for Firth's method function**

```{r}

Firth_method_weibull2 <- function(mle,x,tolerance=0.000001,max_ite=50){   
  sample_weibull <- x
  record <- matrix(0,nrow =max_ite+1,ncol = 2)
  record[1,] <- mle
  #bias <- vector(mode='numeric',length=0)
  diff <- 1
  #i<-1
  for( i in 1:max_ite){
    
  temp <- record[i,]+solve(obs_informa_w(
  record[i,],sample_weibull))%*% matrix(score_weibull(
  record[i,],sample_weibull))
    
    new_candidate <- temp-coxsnell.bc(density = pdf, logdensity = lpdf, n = sample_size,
        parms = c("k", "lambda"), mle = 
  record[i,],
        lower = 0)$bias  #update equation
    record[(i+1),] <-new_candidate #cbind(record,new_candidate)
    #diff <- abs(record[(i+1),][1]-record[i,][1])
    #i <-i+1
  }
  return(record[max_ite,])
}

```

**Codes for One-step method function**

In this case, the cox method becomes a naive bias reduction equation since there is an explicit form of the bias in exponential case.

```{r}
#Contractive iteration
#Formula deduced from Cox-Snell
pdf <- quote(k/lambda^k*x^(k-1)*exp(-(x/lambda)^k))
lpdf <- quote(log(k)-k*log(lambda)+k*log(x)-(x/lambda)^k)

Cox_weibull<- function(mle,x){
  
  n <- length(x)
  
  return(mle-coxsnell.bc(density = pdf, logdensity = lpdf, n = n,
          parms =  c("k", "lambda"), mle =
          mle,
                lower = 0)$bias)

  
}

  
```


**Codes for Bootstrap method function**

The bootstrap method is based on the equation:$\tilde{\theta}- \hat{\theta} \approx \hat{\theta}-\bar{\theta}_{boot}$ and then the bias-corrected MLE $\tilde{\theta}$could be achieved by : $\tilde{\theta}=2 \hat{\theta}-\bar{\theta}_{boot}$, where $\bar{\theta}_{boot}$ is the mean of all bootstrapped MLE under the $\hat{\theta}$.

```{r}
#Bootstrap method

Boot_weibull<- function(mle,x,bootstrap_t =50){
  
  n <- length(x)
  Boot <-  matrix(0,nrow =bootstrap_t,ncol = 2)
  j <- 1
  while( j < (bootstrap_t+1)){ # Bootstrap procedure
      
    sample_weibull <-rweibull(sample_size,shape= mle[1],scale=mle[2])
    MOM_k_weibull <- pi/(sqrt(6)*sd(sample_weibull)) #shape
    MOM_lambda_weibull <- exp(mean(sample_weibull)-0.5772/MOM_k_weibull)  #scale
    model <-  optim(par = c(MOM_k_weibull,MOM_lambda_weibull),target_weibull, x=sample_weibull, hessian=TRUE)
    if( model$convergence ==0){
    Boot[j,] <- model$par
    j <- j +1
    }
  }
  theta_bootstrap <- 2*mle-colMeans(Boot)
  return(theta_bootstrap)   #Bootstrap updating equation
}

  
```


**Codes for Jackknife method function**



```{r}
#Bootstrap method

Jackknife_weibull <- function(mle,x){
  n <- length(x)
  Jack_mle_leave_one_out <-matrix(0,nrow =n,ncol = 2)
  for( i in 1:n){ # Bootstrap procedure
      
      Jackknife_sample <- x[-i]

      MOM_k_weibull <- pi/(sqrt(6)*sd(Jackknife_sample)) #shape
      MOM_lambda_weibull <- exp(mean(Jackknife_sample)-0.5772/MOM_k_weibull)  #scale
      model <-  optim(par = c(MOM_k_weibull,MOM_lambda_weibull),target_weibull, x=Jackknife_sample, hessian=TRUE)

      Jack_mle_leave_one_out[i,] <- model$par

  }
  
  theta_tilde <- n*mle-(n-1)*colMeans(Jack_mle_leave_one_out)
  return(theta_tilde)   #Jackknife equation
}

  
```





Now, we run those methods by 10000 times and compare the mean and the mean squared error of bias-corrected mle of each method. 

```{r,cache=TRUE}

set.seed(1234)

library(mle.tools)
true_k_weibull<-20  #true value
true_lambda_weibull <- 2
sample_size <-20
tolerance <- 0.00001



n_trials <- 1000
bc_weibull_anaiE <- matrix(0,nrow=n_trials,ncol = 2)
bc_weibull_Jacknife<- matrix(0,nrow=n_trials,ncol = 2)
bc_weibull_Boot<- matrix(0,nrow=n_trials,ncol = 2)
bc_weibull_Cox<- matrix(0,nrow=n_trials,ncol = 2)
bc_weibull_iE<- matrix(0,nrow=n_trials,ncol = 2)
bc_weibull_firth <- matrix(0,nrow=n_trials,ncol = 2)
mle_weibull <- matrix(0,nrow=n_trials,ncol = 2)
# negative likelihood function for gamma dist
target_weibull=function(mle,x){-sum(dweibull(x,mle[1],mle[2],log=TRUE))}

#Formula deduced from Cox-Snell
pdf <- quote(k/lambda^k*x^(k-1)*exp(-(x/lambda)^k))
lpdf <- quote(log(k)-k*log(lambda)+k*log(x)-(x/lambda)^k)

#score function of weibull
score_weibull <- function(theta,sample_weibull){
  n<-length(sample_weibull)
  sumlog <- sum(log(sample_weibull))
  x <- sample_weibull
  k <-theta[1]
  lambda <-theta[2]
  score_k <-n/k+sumlog-n*log(lambda)-sum(log(x/lambda)*(x/lambda)^k)
  score_lambda <- -n*k/lambda + sum(k*x^k*lambda^(-k-1))
  return(c(score_k,score_lambda))
}


#observed information matrix
obs_informa_w <- function(theta,sample_weibull){
  n<-length(sample_weibull)
  k <- theta[1]
  lambda <-theta[2]
  x <- sample_weibull
  I_11 <- -n/k^2 -sum((log(x/lambda)^2)*(x/lambda)^k)
  I_12 <- -n/lambda+ sum(x^k/(lambda)^(k+1)*(1+k*log(x/lambda)))
  I_21 <- -n/lambda +sum( (x/lambda)^k  * (1/lambda+k/lambda *log(x/lambda))     )
  I_22 <- -n*k/lambda^2 -sum((k+1)*k*(x^k)*lambda^(-k-2))
  obs_I <- -matrix(c(I_11,I_12,I_21,I_22),ncol = 2)
  return( obs_I)
  
}
t <-1
while(t <= n_trials){

  sample_weibull <-rweibull(sample_size,shape= true_k_weibull,scale=true_lambda_weibull)
  MOM_k_weibull <- pi/(sqrt(6)*sd(sample_weibull)) #shape
  MOM_lambda_weibull <- exp(mean(sample_weibull)-0.5772/MOM_k_weibull)  #scale
  check <-  optim(par = c(MOM_k_weibull,MOM_lambda_weibull),target_weibull, x=sample_weibull, hessian=TRUE)
  #mle_gamma_update<-check$par
  mle_weibull_update<-check$par
  mle_weibull[t,] <- mle_weibull_update
  if ( check$convergence ==0){
#
    try(

      {
      bc_weibull_anaiE[t,] <- iE_weibull_analytical(mle_weibull_update,sample_weibull,max_ite=20)
      bc_weibull_iE[t,] <- iE_weibull(mle_weibull_update[1],mle_weibull_update[2],sample_weibull,max_ite=20,B=50)
      bc_weibull_firth[t,] <-  Firth_method_weibull2(mle_weibull_update,sample_weibull,tolerance = tolerance)
      bc_weibull_Cox[t,] <- Cox_weibull(mle_weibull_update,x=sample_weibull)
      bc_weibull_Boot[t,] <- Boot_weibull(mle_weibull_update,x=sample_weibull,bootstrap_t = 50)
      bc_weibull_Jacknife[t,] <- Jackknife_weibull(mle_weibull_update,x=sample_weibull)
      t <- t+1
      },silent = TRUE
      )
}

}


result_weibull_k <- matrix(0,nrow = 2,ncol =7)
colnames(result_weibull_k) <- c('MLE_alpha','iE alpha','Firth alpha','Cox alpha','Boot alpha','Jack alpha','Analytical iE alpha')
rownames(result_weibull_k) <- c('mean','MSE')

result_weibull_k[1,] <- c(mean(mle_weibull[,1]),mean(bc_weibull_iE[,1]),mean(bc_weibull_firth[,1]),mean(bc_weibull_Cox[,1]),mean(bc_weibull_Boot[,1]),mean(bc_weibull_Jacknife[,1]),mean(bc_weibull_anaiE[,1]))
result_weibull_k[2,] <- c(mean((mle_weibull[,1]-true_k_weibull)^2),mean((bc_weibull_iE[,1]-true_k_weibull)^2),mean((bc_weibull_firth[,1]-true_k_weibull)^2),mean((bc_weibull_Cox[,1]-true_k_weibull)^2),mean((bc_weibull_Boot[,1]-true_k_weibull)^2),mean((bc_weibull_Jacknife[,1]-true_k_weibull)^2),mean((bc_weibull_anaiE[,1]-true_k_weibull)^2))

knitr::kable(
  result_weibull_k, booktabs = TRUE,
  caption = 'Comparison with Firth method in two parameters Weibull distribution with k=20,lambda=2'
)



result_weibull_lambda <- matrix(0,nrow = 2,ncol = 7)
colnames(result_weibull_lambda) <- c('MLE_alpha','iE alpha','Firth alpha','Cox alpha','Boot alpha','Jack alpha','Analytical iE alpha')
rownames(result_weibull_lambda) <- c('mean','MSE')

result_weibull_lambda[1,] <- c(mean(mle_weibull[,2]),mean(bc_weibull_iE[,2]),mean(bc_weibull_firth[,2]),mean(bc_weibull_Cox[,2]),mean(bc_weibull_Boot[,2]),mean(bc_weibull_Jacknife[,2]),mean(bc_weibull_anaiE[,2]))
result_weibull_lambda[2,] <- c(mean((mle_weibull[,2]-true_lambda_weibull)^2),mean((bc_weibull_iE[,2]-true_lambda_weibull)^2),mean((bc_weibull_firth[,2]-true_lambda_weibull)^2),mean((bc_weibull_Cox[,2]-true_lambda_weibull)^2),mean((bc_weibull_Boot[,2]-true_lambda_weibull)^2),mean((bc_weibull_Jacknife[,2]-true_lambda_weibull)^2),mean((bc_weibull_anaiE[,2]-true_lambda_weibull)^2))

knitr::kable(
  result_weibull_lambda, booktabs = TRUE,
  caption = 'Comparison with Firth method in two parameters case.Weibull distribution with k=20,lambda=2'
)
```
